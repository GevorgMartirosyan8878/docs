էսօր խոսալու ենք բաֆռների ու սթրիմերի մասին, բայց միչև սթրիմերին անցնելը,
շատ կարևոր ա հասկանանք ինչ են բաֆռները ... 
node.js-ում կան գլոբալ մոդուլներ, որոնցից մեկը Buffer module-նա,
որը հնարավորություն ա տալիս աշխատել binary data-ի հետ

Նոդի քեյսում, բաֆեռը հիշողության ժամանակավոր ինչ որ հատված ա,
որը մեզ հնարավորություն ա տալիս էֆեկտիվ կառավարել բինարնի դատա-ն,

համակարգչային հիշողության կոնտեքստում չանկը հիշողության բլոկ ա կամ սեգմենտ,
որը նախատեսված ա ֆիքսված չափով ինֆոռմացյա պահելու համար

ինչ ա բաֆեռը ... հիշողության մեջ հատկացված հիշողության մի մաս ա (հիշողության էտ մասը կոչվում ա չանկ),
որի մեջ կարող ենք պահել ֆիքսված չափի բայթերի հաջորդականություն ...

մենք բաֆռները օգտագործելու ենք որ աշխատենք ֆայլային սթրիմերի հետ, 
բայց իրանց օգտագործում են նեթվորք պակետների հետ աշխատելու ժմնկ,
ինչպես ասեցի ֆալյային սթրիմերի ժամանակ, ու այլ տեղերում, որտեղ առընչվում ենք բինառնի դատայի հետ 

հիմա ձեզ ներկայացնեմ բաֆռների մեթոդներից մի քանիսը,
ու հետո անցնենք ամեն մեկին ու քննարկենք ոնց են իրանց օգտագործում

Buffer.alloc(size, fill, encoding) 

Buffer.from()

buffer.toString([encoding, [start, [end]]])

buffer.byteLength

հիմա օրնակներով կուսումնասիրենք տվյալ մեթոդները, հիմնական/գլոբալ պատկերացում կազմելու համար,
մեթոդների ամբողջական ցանկը տեսնելու և ուսումնասիրելու համար մտնում ենք նոդի դոկերը, ու էնտեղից նայում ենք
հիմա ցույց տամ, որտեղա, ու անցնենք առաջ

Buffer.from() -
սարքումա բաֆռ մեր փոխանցած արժեքը տեղադրելով բաֆռի մեջ

Buffer.alloc - 
եթե փոխանցում ենք միայն առաջին պառամետրը
սարքումա կոնկրետ չափի նոր բուֆեռ ու լցնումա բաֆեռը կամ ինիշալայզ ա անում բաֆեռը ու լցնում ա 0-ներով
երկրորդ պառամետրը մեր դատան ա, թե ինչ դատա ենք ուզում պահենք,
երրորդը են էնկոդինգի տեսակն ա որով ուզում ենք բաֆռի մեջ պահենք մեր փոխանցած դատան

buffer.byteLength -
ցույց ա տալիս բայթերի քանակը, որը հատկացված ա բաֆռին


STREAMS

սթրիմը թարգմանաբար պատոկնա, բայց սա ոչ մի կապ չունի մնագապատոչնսծի հետ ... հիմա խոսենք սթրիմերի մասին

Սթրիմերը օգտագործվում են մեծ ծավալով դաննիների, ֆայլերի  ինչպես նաև
ցանցային զապրոսների հետ աշխատելու համար

սթրիմերը հիմնականում լինում են 4 տեսակի

readable - էս տեսակի սթրիմերը օգտագործվում են դաննիներ կարդալու համար, տարբեր տեսակի տեղերի,
շորոնցից են օրինակ սովորական ֆայլերը, կամ ցանցային զապրոսները

writable - բացի ֆայլեր կարդալուց, մենք շատ հաճախ կարիք ենք ունենում գրել ֆայլեր,
որտեղ որ օգտագործվում ա մեր writable սթրիմերը, որը սթրիմի մի այլ տեսակա, իրա միջոցով
մենք կարանք ֆայլեր գրենք մեր համակարգչի մեջ, կամ ռեսպոնս փոխանցենք օգտագործողին

էս երկու տեսակի սթրիմերը հիմնական են համարվում, մնացած սթրիմերը հիմնված են իրանց վրա,
էտ սթրիմերն են

duplex - դուպլեքս տեսակի սթրիմերը օգտագործվում են ֆայլերը միառժամանակ գրելու և կարդալու համար, 
որոնց ամենահայտնի օրինակները request and response օբյեկտներն են

transform - տռանսֆոռմ տեսակի սթրիմերն էլ իրեն հերթին հիմնված են դուպլեքսի վրա,
իրանք նույնպես նախատեսված են ֆայլերը գրելու և կարդալու համար, 
ուղղակի ի տարբերություն դուպլեքս տեսակի սթրիմերից իրանք բացի գրել ու կարդալուց, փոխանցվող ինֆոռմացյան կարող են փոփոխել

---------

նախ ասեմ որ ցանկացած սթրիմ նախ և առաջ սովորական javascript օբյեկտ ա իրանից ներկայացնում

In Node.js, a stream is an abstract interface implemented by various objects to facilitate reading from or writing to a sequence of data

սթրիմը, որը մենք սարքում ենք fs.createReadStream('video.mp4') համարվումա fs.ReadStream ի օբյեկտ,
որը իրա հերթին ժառանգումա stream.Readable կլասից, որն էլ իրա հերթին EventEmitter-ից,
էտա պատճառը որ մեր օբյեկտը ունի մի շարք մեթոդներ ու իվնթներ որոնք հնարավորություն են տալիս կառավարել, 
ու տեղյակ լինել թե որ պահին ինչ ա կատարվում մեր սթրիմի հետ  

սթրիմը սարքելուց հետո, ինքը ավտոմատ սկսումա կարդալ դաննիները ու պահպանել իրա ներքին հիշողությունում,
որի չափը ֆայլային սթրիմերի մեջ կաղզմում ա 64kb, երբ որ ֆայլի, տվյալ դեպքում վիդյոյի առաջին 64kb կարդա,
ինքը ֆսո, դադարելու ա կարդալը, քանի որ իրա ներքին հիշողությունը արդեն սպառվելա, 
ինքը էլ տեղ չունի որտեղ կկարողանա նոր ինֆոն պահել, ու էսպես ասած ինքը սպասում ա երբ էտ գրված դատան,
64kb-ն ինչ որ մեկը կազատի, որ ինքը անցնի առաջ ու մյուս 64kb դատան կարդա ... 
էտ կարող ենք մենք անել, սթրիմի վրա ավելացնելով 'date' իվնթը, որի callback-ը ընդունումա մեկ պառամետր,
որը իրանից ներկայացնումա չանկ, այսինքն հիշողության ինչ որ հատված, որի չափսը մեր դեպքում 64kb ա,   
մեր քոլբեք ֆունկցյան էստեղ կհամարվի արդեն էտ դատան վերցնողը, կամ էսպես ասած ազատողը, 
որը սթրիմի միջից կվերցնի էտ 64kb-ը, ու կազատի տեղ մեր վիդյոյի հաջորդ 64kb-ի համար ...  
ամեն անգամ երբ որ 'date' իվնթը աշխատում ա, էտ ինֆոն, 64kb-ը փոխանցվումա մեր ֆունկցիային,
էտ ձև տեղ ազատելով մեր հաջոր 64kb-ի համար
...
երբ որ սաղ մեր ֆայլը կարդում պրծնումա սթրիմը, էտ ժամանակ աշխատումա 'end' իվթնը

... հիմա
ես փոքր օրինակի վրա մենք արդեն տեսնում ենք առավելություն
նախ են որ իրանք հիշողություն են խնայում, այսինքն, ինչքան էլ որ ֆայլը մեծ լինի, մենք մեկա միառժամանակ
աշխատում ենք փոքր ու ֆիքսված չափսի ինֆոռմացյայի ֆռագմենտների հետ

լավ, բա ինչ կլինի եթե ինչ որ էռոռ ստանանք, կամ օրինակ էտ ֆայը որը կարդում ենք չլինի .. էկեք նայենք

դրա համար, որ ամբողջ ափփը քռաշ չլինի, մենք ունենք ուրիշ իվնթ, որը կոչվում ա 'error', 
որը հենդլ ա են էռռոռները որոնք կարող են առաջանալ սթրիմի աշխատանքի ընթացքում

շատ սկսնակներ, փորձում են try catch ի օգնությամբ հենդլ անենք էռոռները, որը լրիվ անիմաստ ա, 
քանի որ սթրիմերը ֆայլերի հետ աշխատում են ասինխռոն, իսկ ոնց գիտենք, 
try catch կանստռուկցյան բռնում ա միայն սինխռո էռոռները, դրա համար էլ էստեղ ինքը լրիվ անիմաստ ա

բուֆեռի օբյեկտը որը դեֆոլթով օգտագործվումա սթրիմերում, նախատեսված ա բինառնի դատայի հետ աշխատելու համար,
բայց ենթադրենք մեզ պետքա աշխատել տեքստվի ֆայլերի հետ, որպիսի սթրիմը կարդա դաննիները սթրինգի ձևով
դրա համար մենք պետքա էնկոդինգ տանք սթրիմին ...

մեկը պառամետրերով, {encoding: 'utf-8'}

.setEncoding('utf-8')

կարևորա նշել որ էնկոդինգը պետքա տալ մինչև սթրիմը կսկսի 

պետքա նշել որ կախված սթրիմերի տեսակներից, իվնթների նշանակությունը կարա փոխվի ... 

նայենք մյուս իվնթները, ու ընթացքում էլ հասկանանաք

մյուս իվնթ 'open'
որը նշանաակում ա ֆայլի բացվելը, այսինքն 'open' իվնթը լինումա են ժմնկ,
երբ որ ֆայլը հաջողությամբ բացվելա ու արդեն պատրաստ ա կարդալուն կամ գրելուն, բայց օրինակ 
նեթվորք քնեքշնի սթրիմերում էտ իվնթը չկա, իրան փոխարինում ա connect իվթնը,
որը նշանակում ա որ քնեքշնը հաստատվելա արդեն

մյուս իվնթ 'close'
իրա հիմնական միտքը ենա, որ ինքը աշխատումա երբ որ աշխատանքը ավարտվում ա, բայց ֆայլային սթրիմերում, 
ինքը աշխատում ա են ժամանակ երբ որ ֆայլը փակվում ա, 
իսկ նեթվորք քնեքշնի սթրիմերում են ժմնկ ա աշխատում երբ որ քնեքշնը փակվում ա

data
end
error
close

իվնթները կան բոլոր սթրիմերում, ու իրանք համարվում են ամենահաճախ օգտագործվող իվնթները

ԸՆԴՀԱՆՈՒՐ ՍԽԵՄԱՆ

սթրիմը սարքվելուց հետո, տեղի ա ունենում անմիջապես ֆայլի բացվելու գործընթացը,
որի ժմնկ ոնց իմացանք աշխատումա 'open' իվնթը, դրանից հետո սթրիմը սկսելույա կարդալ ֆայլը,
ու ամեն անգամ աշխատացնելույա 'date' իվնթը երբ որ իր հիշողությունը լցված լինի,
որով սենց ասած ասումա, մեզ իմաց ա ատալիս որ, հեյ, ֆսո ինչքան տեղ ունեյի էտքան ինֆո կարդացել եմ,
էկեք վերցրեք, որ իմ գործը շարունակեմ ... հետո ... 
երբ որ սաղ դաննիները կարդա վերջացնի սթրիմը, ու էլ կարդալու բան չմնա, էտ ժմնկ տեղի ա ունենալու
'end' իվնթը, որից հետո, 'close'-ը

կարևորա, չենք մոռանում որ ամեն էտապում կարա լինի 'error' իվնթը, որից հետո անմիջապես աշխատելույա 'close'
իվնթը, կարևորա նշել նաև որ չի աշխատելու 'end' իվնթը, քանի որ 'end' իվնթը աշխատումա են ժմնկ երբ որ 
ֆայլը հաջողությամբ կարդացվել ա սթրիմի կողմից ու պրծել 

մեկ հավելում ևս, ֆայլլային սթրիմերը ունեն 'open' իվնթ,
բայց կախված նրանից թե ինչ սթրիմերի հետ ենք աշխատում հնարավորա և չլինի,



write stream

խոսանք վռայթ սթրիմերի մասին, իրանք նախատեսված են ֆայլեր գրելու համար, 
մեթոդը որը սարքումա գրելու սթրիմերը, նման ա կարդալու սթրիմերին, 
fs.createWriteStream, րոը վերադարձնումա օբյեկտ fs.WriteStream -> stream.Writable -> EventEmitter

մինչև կոդ կգրենք ու կհասկանանք ոնցա աշխատում, մի փոքր բան էլ ասեմ, ու անցնենք օրինակներին
եթե writeStream-ը բացվելու ժմնկ տվայլ ֆայլը չկա, ինքը ավտոմատ սարքելույա էտ ֆայլը, եթե կա, 
մինչև գրելը մաքրիելույա էտ ֆայլի կոնտենտը, ու նոր գրի են ինչը կտանք

հիմնական մեթոդները որ օգտագործվումա writableStream-ենրի համար էտ write() and end() մեթոդներն են
եկեք նայենք տեսնենք ոնց պետքա իրանց օգտագործենք

.write() - մեթոդը նախատեսված ա դաննիների փոխանցման համար, որոնք պետքա գրվեն ֆայլում իրան մի քանի անգամ կարան կանչենք

.end() - զուտ ասումա սթրիմին որ արդեն գրելու բան չկա, ու չի լինելու, ինչ պետքա գրել ենք արդեն, 
էս մեթոդի կանչելուց հետո, ֆայլը փակվումա, ու վերջացնում ա սթրիմի աշխատանքը

կարողա շատ հաճախ էսպիսի սինտաքս տեսնեք .end('hello world'), ինքը նույննա  ինչ որ կանչենք .write('hello world') .end()
էս ձևը զուտ հարմարա օգտագործել կոդը կարճացնելու համար, ուրիշ տարբերություն չկա

եթե սաղ դաննիները բարեհաջող փոխանցվել են, .end մեթոդը կանչվելուց հետո լինելու ա 'finish' իվնթը ... եթե հիշում ենք
ռիդբլ սթրիմների համար կար նմանատիպ event, ուղղակի կոչվում էր 'end' .... տարբեր են կոչվում որպեսզի duplex ու transform
սթրիմերի հետ աշխատելուց խնդիրներ չառաջանան, քանի որ duplex ու transform սթրիմերը
նախատեսված են ֆյլեր գրելու ու կարդալու համար միառժամանակ

երբ որ սթրիմի աշխատանքը վերջանա, դրանից հետո տեղի ա ունենալու 'close' իվնթը, ու իրանից հետո էլ ոչ մի իվնթ տեղի չի ունենալու

միառժամանակ էսքանի հետ, չենք մոռանում որ հենդլ չարած էռոռները մեր ամբողջ ափփը քցելու են, դրա համար չենք մոռանում
հենդլ անենք էռռոռները, զուտ ավելացնելուվ 'error' իվնթը
կարևոր ա նշել որ 'error' իվնթը կոնկրետ ինչն որ կետում չի լինում, քանի որ մենք կարանք Էռռոռ ստանանք ցանկացած պահի,
ֆայլը գրելուց առաջ, կամ հետո կամ գրելու ընթացքում, կամ finish-ից առաջ հետո դրա համար շատ կարևոր ա հենդլ անենք էռռոռները...
կարևոր ա նաև որ էռոռից հետո, finish իվնթը չի աշխատելու, քանի որ ֆինիշը աշխատումա մենակ
հաջողությամ տեղի ունեցած ֆայլերի փոխանակման ավարտից հետո, բայց դե, close-ը աշխատում ա էռռոռից հետո քանի որ

էլի ունի 'open' իվնթը որը աշխատումա ֆայլը հաջողությամբ բացվելուց հետո

----------------
դիսկի հետ գործողությունները ասինխռոն են, ֆայլ բացել փակել գրել կարդալ 
----------------

հիմա էկեք հասկանանք ինչա կատարվում տակից

ստեղծվելուց հետո ռիդ սթրիմը սկսելույա միանգամից կարդալ ֆայլը, ու միանգամից փոխանցելույա վռայթ սթրիմին, 
որը իրա հերթին ֆայլը փոխանցելույա կլիենտին, կամ սկսելույա գրել հիմնական խնդիրը ստեղ կայանում ա նրանում, 
որ մենք ֆայլը կարդալու ենք շատ արագ, քան գրելու ենք իրան, կամ քան փոխանցելու ենք կլիենտին, որպես օրենք,
կլիենտի ինտեռնետի արագությունը ավելի դանդաղ ա քան մեր դիսկի արագությունը, որը կարդալույա էտ ֆայլը
իսկ մինչև դաննիները գրելը, կամ ուղղարկելը կլիենտին, էտ դաննիները պահպանվելու են վռայթ սթիմի մեջ, 
ու երբ որ կլիենտին ենք ուղղարկում ֆայլըւ, կամ գրում ենք դիսկի մեջ, ամեն չանկը գրելուց հետո, էտ չանկը ջնջվում ա սթրիմի հիշողությունից
բայց քանի որ գրելը դանդաղա լինում, մի հատ սիտուացյա ենք ունենալու, երբ որ արդեն սաղ ֆայլը կարդացվելա,
պրծելա, բայց վռայթ սթրիմը դեռ շարունակումա գրել ֆայլը, քանի որ գրելու կամ ուղղարկելու արագությունը դանդաղ ա ավելի
դաժը կարա լինի իրավիճակ, երբ որ հլա դեռ առաջին չանկը չի գրվել, կամ չի ուղղարկվել կլիենտին, 
բայց մենք արդեն սաղ ֆայլը կարդացել պրծել ենք

էս խնդրին ինչ լուծում կա ... մենք ուղղակի պիտի կարդան ֆայլը են արագությամբ, 
ինչ որ վռայթ սթրիմը գրելույա էտ ֆայլը կամ ուղղարկելույա կլիենտին, այսինքն, առաջին չանկը կարդացինք, ֆսո, դադարում ենք կարդալը
ու սպասում ենք մինչև առաջին չանկը կգրվի, դրանից հետո կարդանք երկրորդ չանկը, ու սպասենք մինչև էտ էլ կգրվի ու տենց շարունակ

չնայած նրա որ վռայթ սթրիմերում ներքին հիշողությունը սահմանափակ ա, բայց շատ ճկունա, ու նենցա որ մենք կարանք ինչ չափի ուզում ենք
էտքան ֆայլ գրենք .write(), ինչքանով որ մեր կոմպը կտա ազատ տեղ հիշողության համար, ու էտ դեպքում էլ երբ որ լցվի, մենք էռոռ չենք ստանալու
ուղղակի էտ ժմնկ երբ որ լցված լինի հիշողությունը, ֆայլը գրելուց հետո, ներքին ստուգում ա գնում, եթե տեղ չկա, 
մեր write մեթոդը վերադաձնելույա false, մեր օրինակում իգնոռել ենք էտ պահը, ու էտ կարա բերի նրան որ մեր սթրիմի հիշողությունը լցվի

եկեք ուղղենք էտ

բայց կարա լինի նայև այլ բան

քնեքշնը կարա կտրվի



